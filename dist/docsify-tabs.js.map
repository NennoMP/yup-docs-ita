{"version":3,"file":"docsify-tabs.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/js/index.js"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","// Dependencies\n// =============================================================================\nimport { version as pkgVersion } from '../../package.json';\nimport '../scss/style.scss';\n\n\n// Constants and variables\n// =============================================================================\nconst commentReplaceMark = 'tabs:replace';\nconst classNames = {\n    tabsContainer  : 'content',\n    tabBlock       : 'docsify-tabs',\n    tabButton      : 'docsify-tabs__tab',\n    tabButtonActive: 'docsify-tabs__tab--active',\n    tabContent     : 'docsify-tabs__content'\n};\nconst regex = {\n    // Matches markdown code blocks (inline and multi-line)\n    // Example: ```text```\n    codeMarkup: /(```[\\s\\S]*?```)/gm,\n\n    // Matches tab replacement comment\n    // 0: Match\n    // 1: Replacement HTML\n    commentReplaceMarkup: new RegExp(`<!-- ${commentReplaceMark} (.*) -->`),\n\n    // Matches tab set by start/end comment\n    // 0: Match\n    // 1: Indent\n    // 2: Start comment: <!-- tabs:start -->\n    // 3: Labels and content\n    // 4: End comment: <!-- tabs:end -->\n    tabBlockMarkup: /[\\r\\n]*(\\s*)(<!-+\\s+tabs:\\s*?start\\s+-+>)[\\r\\n]+([\\s|\\S]*?)[\\r\\n\\s]+(<!-+\\s+tabs:\\s*?end\\s+-+>)/m,\n\n    // Matches tab label and content\n    // 0: Match\n    // 1: Label: <!-- tab:Label -->\n    // 2: Content\n    tabCommentMarkup: /<!-+\\s+tab:\\s*(.*)\\s+-+>[\\r\\n]+([\\s\\S]*?)[\\r\\n]+(?=<!-+\\s+tabs?:)/m,\n\n    // Matches tab label and content\n    // 0: Match\n    // 1: Label: #### **Label** OR #### __Label__\n    // 2: Content\n    tabHeadingMarkup: /[\\r\\n]*(\\s*)#{1,6}\\s*[*_]{2}\\s*(.*[^\\s])\\s*[*_]{2}[\\r\\n]+([\\s\\S]*?)(?=#{1,6}\\s*[*_]{2}|<!-+\\s+tabs:\\s*?end\\s+-+>)/m\n};\nconst settings = {\n    persist    : true,\n    sync       : true,\n    theme      : 'classic',\n    tabComments: true,\n    tabHeadings: true\n};\n\n\n// Functions\n// =============================================================================\n/**\n * Converts tab content into \"stage 1\" markup. Stage 1 markup contains temporary\n * comments which are replaced with HTML during Stage 2. This approach allows\n * all markdown to be converted to HTML before tab-specific HTML is added.\n *\n * @param {string} content\n * @returns {string}\n */\nfunction renderTabsStage1(content) {\n    const codeBlockMatch   = content.match(regex.codeMarkup) || [];\n    const codeBlockMarkers = codeBlockMatch.map((item, i) => {\n        const codeMarker = `<!-- ${commentReplaceMark} CODEBLOCK${i} -->`;\n\n        // Replace code block with marker to ensure tab markup within code\n        // blocks is not processed. These markers are replaced with their\n        // associated code blocs after tabs have been processed.\n        content = content.replace(item, codeMarker);\n\n        return codeMarker;\n    });\n    const tabTheme = settings.theme ? `${classNames.tabBlock}--${settings.theme}` : '';\n\n    let tabBlockMatch; // eslint-disable-line no-unused-vars\n    let tabMatch; // eslint-disable-line no-unused-vars\n\n    // Process each tab set\n    while ((tabBlockMatch = regex.tabBlockMarkup.exec(content)) !== null) {\n        let tabBlock            = tabBlockMatch[0];\n        let tabStartReplacement = '';\n        let tabEndReplacement   = '';\n\n        const hasTabComments = settings.tabComments && regex.tabCommentMarkup.test(tabBlock);\n        const hasTabHeadings = settings.tabHeadings && regex.tabHeadingMarkup.test(tabBlock);\n        const tabBlockIndent  = tabBlockMatch[1];\n        const tabBlockStart  = tabBlockMatch[2];\n        const tabBlockEnd    = tabBlockMatch[4];\n\n        if (hasTabComments || hasTabHeadings) {\n            tabStartReplacement = `<!-- ${commentReplaceMark} <div class=\"${[classNames.tabBlock, tabTheme].join(' ')}\"> -->`;\n            tabEndReplacement = `\\n${tabBlockIndent}<!-- ${commentReplaceMark} </div> -->`;\n\n            // Process each tab panel\n            while ((tabMatch = (settings.tabComments ? regex.tabCommentMarkup.exec(tabBlock) : null) || (settings.tabHeadings ? regex.tabHeadingMarkup.exec(tabBlock) : null)) !== null) {\n                const tabTitle   = (tabMatch[2] || '[Tab]').trim();\n                const tabContent = (tabMatch[3] || '').trim();\n\n                tabBlock = tabBlock.replace(tabMatch[0], [\n                    `\\n${tabBlockIndent}<!-- ${commentReplaceMark} <button class=\"${classNames.tabButton}\" data-tab=\"${tabTitle.toLowerCase()}\">${tabTitle}</button> -->`,\n                    `\\n${tabBlockIndent}<!-- ${commentReplaceMark} <div class=\"${classNames.tabContent}\" data-tab-content=\"${tabTitle.toLowerCase()}\"> -->`,\n                    `\\n\\n${tabBlockIndent}${tabContent}`,\n                    `\\n\\n${tabBlockIndent}<!-- ${commentReplaceMark} </div> -->`,\n                ].join(''));\n            }\n        }\n\n        tabBlock = tabBlock.replace(tabBlockStart, tabStartReplacement);\n        tabBlock = tabBlock.replace(tabBlockEnd, tabEndReplacement);\n        content = content.replace(tabBlockMatch[0], tabBlock);\n    }\n\n    // Restore code blocks\n    codeBlockMarkers.forEach((item, i) => {\n        content = content.replace(item, codeBlockMatch[i]);\n    });\n\n    return content;\n}\n\n/**\n * Converts \"stage 1\" markup into final markup by replacing temporary comments\n * with HTML.\n *\n * @param {string} html\n * @returns {string}\n */\nfunction renderTabsStage2(html) {\n    let tabReplaceMatch; // eslint-disable-line no-unused-vars\n\n    while ((tabReplaceMatch = regex.commentReplaceMarkup.exec(html)) !== null) {\n        const tabComment     = tabReplaceMatch[0];\n        const tabReplacement = tabReplaceMatch[1] || '';\n\n        html = html.replace(tabComment, tabReplacement);\n    }\n\n    return html;\n}\n\n/**\n * Sets the initial active tab for each tab group: either the first tab in the\n * group or the last tab clicked (if persist option is enabled).\n */\nfunction setDefaultTabs() {\n    const tabsContainer = document.querySelector(`.${classNames.tabsContainer}`);\n    const tabBlocks     = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabBlock}`)) : [];\n    const tabStorage    = JSON.parse(sessionStorage.getItem(window.location.href)) || {};\n\n    tabBlocks.forEach((tabBlock, index) => {\n        const activeButtonDefault = tabBlock.querySelector(`.${classNames.tabButton}`);\n        const activeButtonPersist = settings.persist ? tabBlock.querySelector(`.${classNames.tabButton}[data-tab=\"${tabStorage[index]}\"]`) : null;\n        const activeButton        = activeButtonPersist || activeButtonDefault;\n\n        activeButton && activeButton.classList.add(classNames.tabButtonActive);\n    });\n}\n\n/**\n * Sets the active tab within a group. Optionally stores the selection so it can\n * persist across page loads and syncs active state to tabs with same data attr.\n *\n * @param {object} elm\n * @param {boolean} isSync\n */\nfunction setActiveTab(elm, isSync) {\n    const isTabButton = elm.classList.contains(classNames.tabButton);\n\n    if (isTabButton) {\n        const activeButton      = elm;\n        const activeButtonLabel = activeButton.getAttribute('data-tab');\n        const tabsContainer     = document.querySelector(`.${classNames.tabsContainer}`);\n        const tabBlock          = activeButton.parentNode;\n        const tabButtons        = Array.apply(null, tabBlock.querySelectorAll(`.${classNames.tabButton}`));\n        const tabBlockOffset    = tabBlock.offsetTop;\n\n        tabButtons.forEach(buttonElm => buttonElm.classList.remove(classNames.tabButtonActive));\n        activeButton.classList.add(classNames.tabButtonActive);\n\n        if (settings.persist) {\n            const tabBlocks     = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabBlock}`)) : [];\n            const tabBlockIndex = tabBlocks.indexOf(tabBlock);\n            const tabStorage    = JSON.parse(sessionStorage.getItem(window.location.href)) || {};\n\n            tabStorage[tabBlockIndex] = activeButtonLabel;\n            sessionStorage.setItem(window.location.href, JSON.stringify(tabStorage));\n        }\n\n        if (settings.sync && !isSync) {\n            const tabButtonMatches = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabButton}[data-tab=\"${activeButtonLabel}\"]`)) : [];\n\n            tabButtonMatches.forEach(tabButtonMatch => {\n                setActiveTab(tabButtonMatch, true);\n            });\n\n            // Maintain position in viewport when tab group's offset changes\n            window.scrollBy(0, 0 - (tabBlockOffset - tabBlock.offsetTop));\n        }\n    }\n}\n\n\n// Plugin\n// =============================================================================\nfunction docsifyTabs(hook, vm) {\n    let hasTabs =false;\n\n    hook.beforeEach(function(content) {\n        hasTabs = regex.tabBlockMarkup.test(content);\n\n        if (hasTabs) {\n            content = renderTabsStage1(content);\n        }\n\n        return content;\n    });\n\n    hook.afterEach(function(html, next) {\n        if (hasTabs) {\n            html = renderTabsStage2(html);\n        }\n\n        next(html);\n    });\n\n    hook.doneEach(function() {\n        if (hasTabs) {\n            setDefaultTabs();\n        }\n    });\n\n    hook.mounted(function() {\n        const tabsContainer = document.querySelector(`.${classNames.tabsContainer}`);\n\n        tabsContainer && tabsContainer.addEventListener('click', function(evt) {\n            setActiveTab(evt.target);\n        });\n    });\n}\n\n\nif (window) {\n    window.$docsify = window.$docsify || {};\n\n    // Add config object\n    window.$docsify.tabs = window.$docsify.tabs || {};\n\n    // Update settings based on $docsify config\n    Object.keys(window.$docsify.tabs).forEach(key => {\n        if (settings.hasOwnProperty(key)) {\n            settings[key] = window.$docsify.tabs[key];\n        }\n    });\n\n    // Add plugin data\n    window.$docsify.tabs.version = pkgVersion;\n\n    // Init plugin\n    if (settings.tabComments || settings.tabHeadings) {\n        window.$docsify.plugins = [].concat(\n            docsifyTabs,\n            (window.$docsify.plugins || [])\n        );\n    }\n}\n"],"names":["styleInject","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","commentReplaceMark","classNames","tabsContainer","tabBlock","tabButton","tabButtonActive","tabContent","regex","codeMarkup","commentReplaceMarkup","RegExp","tabBlockMarkup","tabCommentMarkup","tabHeadingMarkup","settings","persist","sync","theme","tabComments","tabHeadings","renderTabsStage1","content","codeBlockMatch","match","codeBlockMarkers","map","item","i","codeMarker","replace","tabTheme","tabBlockMatch","tabMatch","exec","tabStartReplacement","tabEndReplacement","hasTabComments","test","hasTabHeadings","tabBlockIndent","tabBlockStart","tabBlockEnd","join","tabTitle","trim","toLowerCase","forEach","renderTabsStage2","html","tabReplaceMatch","tabComment","tabReplacement","setDefaultTabs","querySelector","tabBlocks","Array","apply","querySelectorAll","tabStorage","JSON","parse","sessionStorage","getItem","window","location","href","index","activeButtonDefault","activeButtonPersist","activeButton","classList","add","setActiveTab","elm","isSync","isTabButton","contains","activeButtonLabel","getAttribute","parentNode","tabButtons","tabBlockOffset","offsetTop","buttonElm","remove","tabBlockIndex","indexOf","setItem","stringify","tabButtonMatches","tabButtonMatch","scrollBy","docsifyTabs","hook","vm","hasTabs","beforeEach","afterEach","next","doneEach","mounted","addEventListener","evt","target","$docsify","tabs","Object","keys","key","hasOwnProperty","version","pkgVersion","plugins","concat"],"mappings":"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"}