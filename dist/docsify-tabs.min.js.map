{"version":3,"file":"docsify-tabs.min.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/js/index.js"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","// Dependencies\n// =============================================================================\nimport { version as pkgVersion } from '../../package.json';\nimport '../scss/style.scss';\n\n\n// Constants and variables\n// =============================================================================\nconst commentReplaceMark = 'tabs:replace';\nconst classNames = {\n    tabsContainer  : 'content',\n    tabBlock       : 'docsify-tabs',\n    tabButton      : 'docsify-tabs__tab',\n    tabButtonActive: 'docsify-tabs__tab--active',\n    tabContent     : 'docsify-tabs__content'\n};\nconst regex = {\n    // Matches markdown code blocks (inline and multi-line)\n    // Example: ```text```\n    codeMarkup: /(```[\\s\\S]*?```)/gm,\n\n    // Matches tab replacement comment\n    // 0: Match\n    // 1: Replacement HTML\n    commentReplaceMarkup: new RegExp(`<!-- ${commentReplaceMark} (.*) -->`),\n\n    // Matches tab set by start/end comment\n    // 0: Match\n    // 1: Indent\n    // 2: Start comment: <!-- tabs:start -->\n    // 3: Labels and content\n    // 4: End comment: <!-- tabs:end -->\n    tabBlockMarkup: /[\\r\\n]*(\\s*)(<!-+\\s+tabs:\\s*?start\\s+-+>)[\\r\\n]+([\\s|\\S]*?)[\\r\\n\\s]+(<!-+\\s+tabs:\\s*?end\\s+-+>)/m,\n\n    // Matches tab label and content\n    // 0: Match\n    // 1: Label: <!-- tab:Label -->\n    // 2: Content\n    tabCommentMarkup: /<!-+\\s+tab:\\s*(.*)\\s+-+>[\\r\\n]+([\\s\\S]*?)[\\r\\n]+(?=<!-+\\s+tabs?:)/m,\n\n    // Matches tab label and content\n    // 0: Match\n    // 1: Label: #### **Label** OR #### __Label__\n    // 2: Content\n    tabHeadingMarkup: /[\\r\\n]*(\\s*)#{1,6}\\s*[*_]{2}\\s*(.*[^\\s])\\s*[*_]{2}[\\r\\n]+([\\s\\S]*?)(?=#{1,6}\\s*[*_]{2}|<!-+\\s+tabs:\\s*?end\\s+-+>)/m\n};\nconst settings = {\n    persist    : true,\n    sync       : true,\n    theme      : 'classic',\n    tabComments: true,\n    tabHeadings: true\n};\n\n\n// Functions\n// =============================================================================\n/**\n * Converts tab content into \"stage 1\" markup. Stage 1 markup contains temporary\n * comments which are replaced with HTML during Stage 2. This approach allows\n * all markdown to be converted to HTML before tab-specific HTML is added.\n *\n * @param {string} content\n * @returns {string}\n */\nfunction renderTabsStage1(content) {\n    const codeBlockMatch   = content.match(regex.codeMarkup) || [];\n    const codeBlockMarkers = codeBlockMatch.map((item, i) => {\n        const codeMarker = `<!-- ${commentReplaceMark} CODEBLOCK${i} -->`;\n\n        // Replace code block with marker to ensure tab markup within code\n        // blocks is not processed. These markers are replaced with their\n        // associated code blocs after tabs have been processed.\n        content = content.replace(item, codeMarker);\n\n        return codeMarker;\n    });\n    const tabTheme = settings.theme ? `${classNames.tabBlock}--${settings.theme}` : '';\n\n    let tabBlockMatch; // eslint-disable-line no-unused-vars\n    let tabMatch; // eslint-disable-line no-unused-vars\n\n    // Process each tab set\n    while ((tabBlockMatch = regex.tabBlockMarkup.exec(content)) !== null) {\n        let tabBlock            = tabBlockMatch[0];\n        let tabStartReplacement = '';\n        let tabEndReplacement   = '';\n\n        const hasTabComments = settings.tabComments && regex.tabCommentMarkup.test(tabBlock);\n        const hasTabHeadings = settings.tabHeadings && regex.tabHeadingMarkup.test(tabBlock);\n        const tabBlockIndent  = tabBlockMatch[1];\n        const tabBlockStart  = tabBlockMatch[2];\n        const tabBlockEnd    = tabBlockMatch[4];\n\n        if (hasTabComments || hasTabHeadings) {\n            tabStartReplacement = `<!-- ${commentReplaceMark} <div class=\"${[classNames.tabBlock, tabTheme].join(' ')}\"> -->`;\n            tabEndReplacement = `\\n${tabBlockIndent}<!-- ${commentReplaceMark} </div> -->`;\n\n            // Process each tab panel\n            while ((tabMatch = (settings.tabComments ? regex.tabCommentMarkup.exec(tabBlock) : null) || (settings.tabHeadings ? regex.tabHeadingMarkup.exec(tabBlock) : null)) !== null) {\n                const tabTitle   = (tabMatch[2] || '[Tab]').trim();\n                const tabContent = (tabMatch[3] || '').trim();\n\n                tabBlock = tabBlock.replace(tabMatch[0], [\n                    `\\n${tabBlockIndent}<!-- ${commentReplaceMark} <button class=\"${classNames.tabButton}\" data-tab=\"${tabTitle.toLowerCase()}\">${tabTitle}</button> -->`,\n                    `\\n${tabBlockIndent}<!-- ${commentReplaceMark} <div class=\"${classNames.tabContent}\" data-tab-content=\"${tabTitle.toLowerCase()}\"> -->`,\n                    `\\n\\n${tabBlockIndent}${tabContent}`,\n                    `\\n\\n${tabBlockIndent}<!-- ${commentReplaceMark} </div> -->`,\n                ].join(''));\n            }\n        }\n\n        tabBlock = tabBlock.replace(tabBlockStart, tabStartReplacement);\n        tabBlock = tabBlock.replace(tabBlockEnd, tabEndReplacement);\n        content = content.replace(tabBlockMatch[0], tabBlock);\n    }\n\n    // Restore code blocks\n    codeBlockMarkers.forEach((item, i) => {\n        content = content.replace(item, codeBlockMatch[i]);\n    });\n\n    return content;\n}\n\n/**\n * Converts \"stage 1\" markup into final markup by replacing temporary comments\n * with HTML.\n *\n * @param {string} html\n * @returns {string}\n */\nfunction renderTabsStage2(html) {\n    let tabReplaceMatch; // eslint-disable-line no-unused-vars\n\n    while ((tabReplaceMatch = regex.commentReplaceMarkup.exec(html)) !== null) {\n        const tabComment     = tabReplaceMatch[0];\n        const tabReplacement = tabReplaceMatch[1] || '';\n\n        html = html.replace(tabComment, tabReplacement);\n    }\n\n    return html;\n}\n\n/**\n * Sets the initial active tab for each tab group: either the first tab in the\n * group or the last tab clicked (if persist option is enabled).\n */\nfunction setDefaultTabs() {\n    const tabsContainer = document.querySelector(`.${classNames.tabsContainer}`);\n    const tabBlocks     = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabBlock}`)) : [];\n    const tabStorage    = JSON.parse(sessionStorage.getItem(window.location.href)) || {};\n\n    tabBlocks.forEach((tabBlock, index) => {\n        const activeButtonDefault = tabBlock.querySelector(`.${classNames.tabButton}`);\n        const activeButtonPersist = settings.persist ? tabBlock.querySelector(`.${classNames.tabButton}[data-tab=\"${tabStorage[index]}\"]`) : null;\n        const activeButton        = activeButtonPersist || activeButtonDefault;\n\n        activeButton && activeButton.classList.add(classNames.tabButtonActive);\n    });\n}\n\n/**\n * Sets the active tab within a group. Optionally stores the selection so it can\n * persist across page loads and syncs active state to tabs with same data attr.\n *\n * @param {object} elm\n * @param {boolean} isSync\n */\nfunction setActiveTab(elm, isSync) {\n    const isTabButton = elm.classList.contains(classNames.tabButton);\n\n    if (isTabButton) {\n        const activeButton      = elm;\n        const activeButtonLabel = activeButton.getAttribute('data-tab');\n        const tabsContainer     = document.querySelector(`.${classNames.tabsContainer}`);\n        const tabBlock          = activeButton.parentNode;\n        const tabButtons        = Array.apply(null, tabBlock.querySelectorAll(`.${classNames.tabButton}`));\n        const tabBlockOffset    = tabBlock.offsetTop;\n\n        tabButtons.forEach(buttonElm => buttonElm.classList.remove(classNames.tabButtonActive));\n        activeButton.classList.add(classNames.tabButtonActive);\n\n        if (settings.persist) {\n            const tabBlocks     = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabBlock}`)) : [];\n            const tabBlockIndex = tabBlocks.indexOf(tabBlock);\n            const tabStorage    = JSON.parse(sessionStorage.getItem(window.location.href)) || {};\n\n            tabStorage[tabBlockIndex] = activeButtonLabel;\n            sessionStorage.setItem(window.location.href, JSON.stringify(tabStorage));\n        }\n\n        if (settings.sync && !isSync) {\n            const tabButtonMatches = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabButton}[data-tab=\"${activeButtonLabel}\"]`)) : [];\n\n            tabButtonMatches.forEach(tabButtonMatch => {\n                setActiveTab(tabButtonMatch, true);\n            });\n\n            // Maintain position in viewport when tab group's offset changes\n            window.scrollBy(0, 0 - (tabBlockOffset - tabBlock.offsetTop));\n        }\n    }\n}\n\n\n// Plugin\n// =============================================================================\nfunction docsifyTabs(hook, vm) {\n    let hasTabs =false;\n\n    hook.beforeEach(function(content) {\n        hasTabs = regex.tabBlockMarkup.test(content);\n\n        if (hasTabs) {\n            content = renderTabsStage1(content);\n        }\n\n        return content;\n    });\n\n    hook.afterEach(function(html, next) {\n        if (hasTabs) {\n            html = renderTabsStage2(html);\n        }\n\n        next(html);\n    });\n\n    hook.doneEach(function() {\n        if (hasTabs) {\n            setDefaultTabs();\n        }\n    });\n\n    hook.mounted(function() {\n        const tabsContainer = document.querySelector(`.${classNames.tabsContainer}`);\n\n        tabsContainer && tabsContainer.addEventListener('click', function(evt) {\n            setActiveTab(evt.target);\n        });\n    });\n}\n\n\nif (window) {\n    window.$docsify = window.$docsify || {};\n\n    // Add config object\n    window.$docsify.tabs = window.$docsify.tabs || {};\n\n    // Update settings based on $docsify config\n    Object.keys(window.$docsify.tabs).forEach(key => {\n        if (settings.hasOwnProperty(key)) {\n            settings[key] = window.$docsify.tabs[key];\n        }\n    });\n\n    // Add plugin data\n    window.$docsify.tabs.version = pkgVersion;\n\n    // Init plugin\n    if (settings.tabComments || settings.tabHeadings) {\n        window.$docsify.plugins = [].concat(\n            docsifyTabs,\n            (window.$docsify.plugins || [])\n        );\n    }\n}\n"],"names":["css","ref","head","style","insertAt","document","getElementsByTagName","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","commentReplaceMark","classNames","tabsContainer","tabBlock","tabButton","tabButtonActive","tabContent","regex","codeMarkup","commentReplaceMarkup","RegExp","tabBlockMarkup","tabCommentMarkup","tabHeadingMarkup","settings","persist","sync","theme","tabComments","tabHeadings","window","$docsify","tabs","Object","keys","forEach","key","hasOwnProperty","version","plugins","concat","hook","vm","hasTabs","beforeEach","content","test","tabBlockMatch","tabMatch","codeBlockMatch","match","codeBlockMarkers","map","item","i","codeMarker","replace","tabTheme","exec","tabStartReplacement","tabEndReplacement","hasTabComments","hasTabHeadings","tabBlockIndent","tabBlockStart","tabBlockEnd","join","tabTitle","trim","toLowerCase","renderTabsStage1","afterEach","html","next","tabReplaceMatch","tabComment","tabReplacement","renderTabsStage2","doneEach","tabBlocks","tabStorage","querySelector","Array","apply","querySelectorAll","JSON","parse","sessionStorage","getItem","location","href","index","activeButtonDefault","activeButton","classList","add","mounted","addEventListener","evt","setActiveTab","elm","isSync","activeButtonLabel","tabButtons","tabBlockOffset","tabBlockIndex","contains","getAttribute","parentNode","offsetTop","buttonElm","remove","indexOf","setItem","stringify","tabButtonMatch","scrollBy","target"],"mappings":"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"}